'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var package_json = require('eslint/package.json');
var eslintMdx = require('eslint-mdx');
var reactNoUnescapedEntities = _interopDefault(require('eslint-plugin-react/lib/rules/no-unescaped-entities'));
var esLintNoUnusedExpressions = _interopDefault(require('eslint/lib/rules/no-unused-expressions'));
var path = _interopDefault(require('path'));
var vfile = _interopDefault(require('vfile'));
var cosmiconfig = require('cosmiconfig');
var remarkMdx = _interopDefault(require('remark-mdx'));
var remarkParse = _interopDefault(require('remark-parse'));
var remarkStringify = _interopDefault(require('remark-stringify'));
var unified = _interopDefault(require('unified'));

var base = {
    parser: 'eslint-mdx',
    plugins: ['mdx'],
};

var getGlobals = function (sources, initialGlobals) {
    if (initialGlobals === void 0) { initialGlobals = {}; }
    return (Array.isArray(sources)
        ? sources
        : Object.keys(sources)).reduce(function (globals, source) {
        var _a;
        return Object.assign(globals, (_a = {},
            _a[source] = false,
            _a));
    }, initialGlobals);
};

var rebass;
try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    rebass = require('rebass');
}
catch (_a) {
    // `rebass`(or `reflexbox` actually) requires `react` as peerDependency, but not all projects using `mdx` are `React` based, so we fallback to hardcoded `rebass` Components here
    /* istanbul ignore next */
    rebass = ['Box', 'Flex', 'Text', 'Heading', 'Link', 'Button', 'Image', 'Card'];
}
var overrides = tslib.__assign(tslib.__assign({}, base), { globals: getGlobals(rebass, {
        React: false,
    }), rules: {
        'lines-between-class-members': 0,
        'react/jsx-no-undef': [
            2,
            {
                allowGlobals: true,
            },
        ],
        'react/react-in-jsx-scope': 0,
    } });

var minorVersion = +package_json.version
    .split('.')
    .slice(0, 2)
    .join('.');
var recommended = tslib.__assign(tslib.__assign({}, base), { rules: {
        'mdx/no-jsx-html-comments': 2,
        'mdx/no-unescaped-entities': 1,
        'mdx/no-unused-expressions': 2,
        'mdx/remark': 1,
        'no-unused-expressions': 0,
        'react/no-unescaped-entities': 0,
    } });
var OVERRIDES_AVAILABLE_VERSION = 6.4;
// overrides in npm pkg is supported after v6.4.0
// istanbul ignore else
if (minorVersion >= OVERRIDES_AVAILABLE_VERSION) {
    var overrides$1 = [
        {
            files: '*.mdx',
            extends: 'plugin:mdx/overrides',
        },
    ];
    try {
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('prettier');
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('eslint-plugin-prettier');
        overrides$1.push({
            files: '*.md',
            rules: {
                'prettier/prettier': [
                    2,
                    {
                        parser: 'markdown',
                    },
                ],
            },
        });
    }
    catch (e) { }
    Object.assign(recommended, {
        overrides: overrides$1,
    });
}



var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  base: base,
  overrides: overrides,
  recommended: recommended
});

var noJsxHtmlComments = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Forbid invalid html style comments in jsx block',
            category: 'SyntaxError',
            recommended: true,
        },
        messages: {
            jsxHtmlComments: 'html style comments are invalid in jsx: {{ origin }}',
        },
        fixable: 'code',
        schema: [],
    },
    create: function (context) {
        return {
            ExpressionStatement: function (node) {
                var invalidNodes = context.parserServices.JSXElementsWithHTMLComments;
                if (!eslintMdx.JSX_TYPES.includes(node.expression.type) ||
                    node.parent.type !== 'Program' ||
                    !invalidNodes ||
                    invalidNodes.length === 0) {
                    return;
                }
                var invalidNode = invalidNodes.shift();
                if (invalidNode.data.inline) {
                    return;
                }
                var comments = invalidNode.data.comments;
                comments.forEach(function (_a) {
                    var fixed = _a.fixed, loc = _a.loc, origin = _a.origin;
                    return context.report({
                        messageId: 'jsxHtmlComments',
                        data: {
                            origin: origin,
                        },
                        loc: loc,
                        node: node,
                        fix: function (fixer) {
                            return fixer.replaceTextRange([loc.start.offset, loc.end.offset], fixed);
                        },
                    });
                });
            },
        };
    },
};

/// <reference path="../../typings.d.ts" />
// copied from `eslint-plugin-react`
var DEFAULTS = [
    {
        char: '>',
        alternatives: ['&gt;'],
    },
    {
        char: '"',
        alternatives: ['&quot;', '&ldquo;', '&#34;', '&rdquo;'],
    },
    {
        char: "'",
        alternatives: ['&apos;', '&lsquo;', '&#39;', '&rsquo;'],
    },
    {
        char: '}',
        alternatives: ['&#125;'],
    },
];
var EXPRESSION = 'Literal, JSXText';
var noUnescapedEntities = tslib.__assign(tslib.__assign({}, reactNoUnescapedEntities), { create: function (context) {
        var _a;
        var configuration = context.options[0] || {};
        var entities = configuration.forbid || DEFAULTS;
        return _a = {},
            // eslint-disable-next-line sonarjs/cognitive-complexity
            _a[EXPRESSION] = function (node) {
                var parent = node.parent;
                if (!eslintMdx.isJsxNode(parent)) {
                    return;
                }
                while (parent) {
                    if (parent.parent.type === 'Program') {
                        break;
                    }
                    else {
                        parent = parent.parent;
                    }
                }
                var _a = node.loc, _b = _a.start, startLine = _b.line, startColumn = _b.column, _c = _a.end, endLine = _c.line, endColumn = _c.column;
                var lines = context.getSourceCode().lines;
                var firstLineOffset = parent.loc.start.line < startLine
                    ? 0
                    : lines
                        .slice(startLine - 1, endLine)
                        .join('\n')
                        .search(eslintMdx.openTag);
                /* istanbul ignore if */
                if (firstLineOffset < 0) {
                    // should never happen, just for robustness
                    firstLineOffset = 0;
                }
                var _loop_1 = function (i) {
                    var rawLine = lines[i - 1];
                    var start = 0;
                    var end = rawLine.length;
                    if (i === startLine) {
                        start = startColumn + firstLineOffset;
                    }
                    if (i === endLine) {
                        end = endColumn;
                        if (i === startLine) {
                            end += firstLineOffset;
                        }
                    }
                    rawLine = rawLine.slice(start, end);
                    entities.forEach(function (entity) {
                        // eslint-disable-next-line unicorn/no-for-loop
                        for (var index = 0; index < rawLine.length; index++) {
                            var char = rawLine[index];
                            if (typeof entity === 'string') {
                                if (char === entity) {
                                    context.report({
                                        loc: { line: i, column: start + index },
                                        message: "HTML entity, `" + entity + "` , must be escaped.",
                                        node: node,
                                    });
                                }
                            }
                            else if (char === entity.char) {
                                context.report({
                                    loc: { line: i, column: start + index },
                                    message: "`" + entity.char + "` can be escaped with " + entity.alternatives
                                        .map(function (alt) { return '``'.split('').join(alt); })
                                        .join(', ') + ".",
                                    node: node,
                                });
                            }
                        }
                    });
                };
                for (var i = startLine; i <= endLine; i++) {
                    _loop_1(i);
                }
            },
            _a;
    } });

/// <reference path="../../typings.d.ts" />
var noUnusedExpressions = tslib.__assign(tslib.__assign({}, esLintNoUnusedExpressions), { create: function (context) {
        var esLintRuleListener = esLintNoUnusedExpressions.create(context);
        return {
            ExpressionStatement: function (node) {
                if (eslintMdx.isJsxNode(node.expression) && node.parent.type === 'Program') {
                    return;
                }
                esLintRuleListener.ExpressionStatement(node);
            },
        };
    } });

var requirePkg = function (plugin, prefix, filePath) {
    if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
        plugin = path.resolve(path.dirname(filePath), plugin);
    }
    prefix = prefix.endsWith('-') ? prefix : prefix + '-';
    var packages = [
        plugin,
        plugin.startsWith('@')
            ? plugin.replace('/', '/' + prefix)
            : prefix + plugin,
    ];
    var error;
    for (var _i = 0, packages_1 = packages; _i < packages_1.length; _i++) {
        var pkg = packages_1[_i];
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
            return require(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
};
var searchSync;
var remarkProcessor;
var getRemarkProcessor = function (searchFrom) {
    if (!searchSync) {
        searchSync = cosmiconfig.cosmiconfigSync('remark', {
            packageProp: 'remarkConfig',
        }).search;
    }
    if (!remarkProcessor) {
        remarkProcessor = unified()
            .use(remarkParse)
            .freeze();
    }
    /* istanbul ignore next */
    var _a = searchSync(searchFrom) || {}, config = _a.config, filepath = _a.filepath;
    /* istanbul ignore next */
    var _b = config || {}, _c = _b.plugins, plugins = _c === void 0 ? [] : _c, settings = _b.settings;
    try {
        // disable this rule automatically since we already have a parser option `extensions`
        // eslint-disable-next-line node/no-extraneous-require
        plugins.push([require.resolve('remark-lint-file-extension'), false]);
    }
    catch (e) {
        // just ignore if the package does not
    }
    return plugins
        .reduce(function (processor, pluginWithSettings) {
        var _a = Array.isArray(pluginWithSettings)
            ? pluginWithSettings
            : [pluginWithSettings], plugin = _a[0], pluginSettings = _a.slice(1);
        return processor.use.apply(processor, tslib.__spreadArrays([
            /* istanbul ignore next */
            typeof plugin === 'string'
                ? requirePkg(plugin, 'remark', filepath)
                : plugin], pluginSettings));
    }, remarkProcessor()
        .use({ settings: settings })
        .use(remarkStringify)
        .use(remarkMdx))
        .freeze();
};

var remark = {
    meta: {
        type: 'layout',
        docs: {
            description: 'Linter integration with remark plugins',
            category: 'Stylistic Issues',
            recommended: true,
        },
        messages: {
            remarkReport: '{{ source }}:{{ ruleId }} - {{ reason }}',
        },
        fixable: 'code',
        schema: [],
    },
    create: function (context) {
        var filename = context.getFilename();
        var extname = path.extname(filename);
        var sourceCode = context.getSourceCode();
        var extensions = eslintMdx.DEFAULT_EXTENSIONS.concat(context.parserOptions.extensions || [], eslintMdx.MARKDOWN_EXTENSIONS, context.parserOptions.markdownExtensions || []);
        return {
            Program: function (node) {
                /* istanbul ignore if */
                if (!extensions.includes(extname)) {
                    return;
                }
                var sourceText = sourceCode.getText(node);
                var remarkProcessor = getRemarkProcessor(filename);
                var file = remarkProcessor.processSync(vfile({
                    path: filename,
                    contents: sourceText,
                }));
                file.messages.forEach(function (_a) {
                    var source = _a.source, reason = _a.reason, ruleId = _a.ruleId, _b = _a.location, start = _b.start, end = _b.end;
                    return context.report({
                        messageId: 'remarkReport',
                        data: {
                            reason: reason,
                            source: source,
                            ruleId: ruleId,
                        },
                        loc: {
                            // ! eslint ast column is 0-indexed, but unified is 1-indexed
                            start: tslib.__assign(tslib.__assign({}, start), { column: start.column - 1 }),
                            end: tslib.__assign(tslib.__assign({}, end), { column: end.column - 1 }),
                        },
                        node: node,
                        fix: function (fixer) {
                            /* istanbul ignore if */
                            if (start.offset == null) {
                                return null;
                            }
                            var range = [
                                start.offset,
                                /* istanbul ignore next */
                                end.offset == null ? start.offset + 1 : end.offset,
                            ];
                            var partialText = sourceText.slice.apply(sourceText, range);
                            var fixed = remarkProcessor
                                .processSync(partialText)
                                .toString();
                            return fixer.replaceTextRange(range, 
                            /* istanbul ignore next */
                            partialText.endsWith('\n') ? fixed : fixed.slice(0, -1));
                        },
                    });
                });
            },
        };
    },
};

var rules = {
    'no-jsx-html-comments': noJsxHtmlComments,
    'no-unescaped-entities': noUnescapedEntities,
    'no-unused-expressions': noUnusedExpressions,
    remark: remark,
};

exports.configs = index;
exports.getGlobals = getGlobals;
exports.getRemarkProcessor = getRemarkProcessor;
exports.noJsxHtmlComments = noJsxHtmlComments;
exports.noUnescapedEntities = noUnescapedEntities;
exports.noUnusedExpressions = noUnusedExpressions;
exports.remark = remark;
exports.requirePkg = requirePkg;
exports.rules = rules;
