import { parse as parse$1 } from 'espree';
import path from 'path';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import unified from 'unified';

/// <reference path="../typings.d.ts" />
const FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    'babel-eslint',
];
const JSX_TYPES = ['JSXElement', 'JSXFragment'];
const isJsxNode = (node) => JSX_TYPES.includes(node.type);
// eslint-disable-next-line sonarjs/cognitive-complexity
const normalizeParser = (parser) => {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError(`Invalid custom parser for \`eslint-mdx\`: ${parser}`);
        }
        return [parser];
    }
    const parsers = [parse$1];
    // try to load FALLBACK_PARSERS automatically
    for (const fallback of FALLBACK_PARSERS) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports,@typescript-eslint/no-var-requires
            const fallbackParser = require(fallback);
            /* istanbul ignore next */
            const parserFn = 'parseForESLint' in fallbackParser
                ? fallbackParser.parseForESLint
                : fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.unshift(parserFn);
            }
            break;
        }
        catch (e) { }
    }
    return parsers;
};
const normalizePosition = (position) => {
    const start = position.start.offset;
    const end = position.end.offset;
    return {
        range: [start, end],
        loc: Object.assign({}, position),
        start,
        end,
    };
};
function restoreNodeLocation(node, startLine, offset) {
    if (!node || !node.loc || !node.range) {
        return node;
    }
    Object.entries(node).forEach(([key, value]) => {
        if (!value) {
            return;
        }
        if (Array.isArray(value)) {
            node[key] = value.map(child => restoreNodeLocation(child, startLine, offset));
        }
        else {
            node[key] = restoreNodeLocation(value, startLine, offset);
        }
    });
    const { loc: { start: startLoc, end: endLoc }, range, } = node;
    const start = range[0] + offset;
    const end = range[1] + offset;
    return Object.assign(Object.assign({}, node), { start,
        end, range: [start, end], loc: {
            start: {
                line: startLine + startLoc.line,
                column: startLoc.column,
            },
            end: {
                line: startLine + endLoc.line,
                column: endLoc.column,
            },
        } });
}
const first = (items) => items && items[0];
const last = (items) => items && items[items.length - 1];
const hasProperties = (obj, properties) => properties.every(property => property in obj);

// based on https://github.com/mdx-js/mdx/blob/master/packages/remark-mdx/tag.js
const dotAllPolyfill = '[\0-\uFFFF]';
const attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
const unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
const singleQuoted = "'[^']*'";
const doubleQuoted = '"[^"]*"';
const jsProps = '{.*}'.replace('.', dotAllPolyfill);
const attributeValue = '(?:' +
    unquoted +
    '|' +
    singleQuoted +
    '|' +
    doubleQuoted +
    '|' +
    jsProps +
    ')';
const attribute = '(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
const openTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*>';
const closeTag = '<\\s*\\/[A-Za-z]*[A-Za-z0-9\\.\\-]*\\s*>';
const selfClosingTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*\\/?>';
const comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
const commentOpen = '(<!---*)';
const commentClose = '(-*-->)';
const OPEN_TAG_REGEX = new RegExp(`^(?:${openTag})$`);
const CLOSE_TAG_REGEX = new RegExp(`^(?:${closeTag})$`);
const OPEN_CLOSE_TAG_REGEX = new RegExp(`^(?:${openTag + '[\\s\\S]*' + closeTag})$`);
const SELF_CLOSING_TAG_REGEX = new RegExp(`^(?:${selfClosingTag})$`);
const COMMENT_REGEX = new RegExp(`^(?:${comment})$`);
const COMMENT_CONTENT_REGEX = new RegExp(`${commentOpen}([\\s\\S]*?)${commentClose}`, 'g');
const isOpenTag = (text) => OPEN_TAG_REGEX.test(text);
const isCloseTag = (text) => CLOSE_TAG_REGEX.test(text);
const isComment = (text) => COMMENT_REGEX.test(text);
// the following functions are only declared for robustness and should never be called
/* istanbul ignore next */
const isOpenCloseTag = (text) => OPEN_CLOSE_TAG_REGEX.test(text);
// prettier-ignore
/* istanbul ignore next */
const isSelfClosingTag = (text) => SELF_CLOSING_TAG_REGEX.test(text);

class Traverse {
    constructor({ enter }) {
        this._enter = enter;
    }
    combineLeftJsxNodes(jsxNodes) {
        return {
            type: 'jsx',
            data: jsxNodes[0].data,
            value: jsxNodes.reduce((acc, { value }) => (acc += value), ''),
            position: {
                start: jsxNodes[0].position.start,
                end: last(jsxNodes).position.end,
            },
        };
    }
    // fix #7
    combineJsxNodes(nodes, parent) {
        let offset = 0;
        const jsxNodes = [];
        const { length } = nodes;
        // eslint-disable-next-line sonarjs/cognitive-complexity
        return nodes.reduce((acc, node, index) => {
            if (node.type === 'jsx') {
                const value = node.value;
                if (isOpenTag(value)) {
                    offset++;
                    jsxNodes.push(node);
                }
                else {
                    if (isCloseTag(value)) {
                        offset--;
                        jsxNodes.push(node);
                    }
                    // prettier-ignore
                    /* istanbul ignore next */
                    else if (!isComment(value) &&
                        !isSelfClosingTag(value) &&
                        !isOpenCloseTag(value)) {
                        try {
                            // fix #138
                            const nodes = parser.normalizeJsxNode(node, parent);
                            jsxNodes.push(...(Array.isArray(nodes) ? nodes : [nodes]));
                        }
                        catch (_a) {
                            // should never happen, just for robustness
                            const { start } = node.position;
                            throw Object.assign(new SyntaxError('unknown jsx node: ' + JSON.stringify(value)), {
                                lineNumber: start.line,
                                column: start.column,
                                index: start.offset,
                            });
                        }
                    }
                    else {
                        jsxNodes.push(node);
                    }
                    if (!offset) {
                        acc.push(this.combineLeftJsxNodes(jsxNodes));
                        jsxNodes.length = 0;
                    }
                }
            }
            else if (offset) {
                jsxNodes.push(node);
            }
            else {
                acc.push(node);
            }
            if (index === length - 1 && jsxNodes.length > 0) {
                acc.push(this.combineLeftJsxNodes(jsxNodes));
            }
            return acc;
        }, []);
    }
    traverse(node, parent) {
        /* istanbul ignore if */
        if (!node) {
            // should never happen, just for robustness
            return;
        }
        let children = node.children;
        if (children) {
            const parent = node;
            children = node.children = this.combineJsxNodes(children, parent);
            children.forEach(child => this.traverse(child, parent));
        }
        this._enter(node, parent);
    }
}
const traverse = (root, options) => new Traverse(options).traverse(root);

const mdxProcessor = unified()
    .use(remarkParse)
    .use(remarkMdx)
    .freeze();
const AST_PROPS = ['body', 'comments', 'tokens'];
const ES_NODE_TYPES = ['export', 'import', 'jsx'];
const LOC_ERROR_PROPERTIES = ['column', 'index', 'lineNumber'];
const DEFAULT_EXTENSIONS = ['.mdx'];
const MARKDOWN_EXTENSIONS = ['.md'];
const DEFAULT_PARSER_OPTIONS = {
    comment: true,
    ecmaFeatures: {
        jsx: true,
    },
    ecmaVersion: new Date().getUTCFullYear(),
    sourceType: 'module',
    tokens: true,
    filePath: '__placeholder__.mdx',
};
const JSX_WRAPPER_START = '<$>';
const JSX_WRAPPER_END = '</$>';
const OFFSET = JSX_WRAPPER_START.length;
class Parser {
    constructor() {
        // @internal
        this._options = DEFAULT_PARSER_OPTIONS;
        this.parse = this.parse.bind(this);
        this.parseForESLint = this.parseForESLint.bind(this);
    }
    normalizeJsxNode(node, parent, options = this._options) {
        const value = node.value;
        if (node.type !== 'jsx' || isComment(value)) {
            return node;
        }
        const commentContent = COMMENT_CONTENT_REGEX.exec(value);
        if (commentContent) {
            const comments = [];
            const { position: { start: { line, column, offset: startOffset }, }, } = node;
            Object.assign(node, {
                data: Object.assign(Object.assign({}, node.data), { jsxType: 'JSXElementWithHTMLComments', comments, 
                    // jsx in paragraph is considered as plain html in mdx, what means html style comments are valid
                    // TODO: in this case, jsx style comments could be a mistake
                    inline: !!parent && parent.type !== 'root' }),
                value: value.replace(COMMENT_CONTENT_REGEX, (matched, $0, $1, $2, offset) => {
                    const endOffset = offset + matched.length;
                    const startLines = value.slice(0, offset).split('\n');
                    const endLines = value.slice(0, endOffset).split('\n');
                    const fixed = `{/${'*'.repeat($0.length - 2)}${$1}${'*'.repeat($2.length - 2)}/}`;
                    const startLineOffset = startLines.length - 1;
                    const endLineOffset = endLines.length - 1;
                    comments.push({
                        fixed,
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        loc: {
                            start: {
                                line: line + startLineOffset,
                                column: last(startLines).length +
                                    (startLineOffset ? 0 : column - 1),
                                offset: startOffset + offset,
                            },
                            end: {
                                line: line + endLineOffset,
                                column: last(endLines).length + (endLineOffset ? 0 : column - 1),
                                offset: startOffset + endOffset,
                            },
                        },
                        origin: matched,
                    });
                    return fixed;
                }),
            });
        }
        return this._normalizeJsxNodes(node, options);
    }
    parse(code, options) {
        return this.parseForESLint(code, options).ast;
    }
    parseForESLint(code, options) {
        const extname = path.extname(options.filePath);
        const isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        const isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        if (!isMdx && !isMarkdown) {
            return this._eslintParse(code, options);
        }
        const root = mdxProcessor.parse(code);
        this._ast = Object.assign(Object.assign({}, normalizePosition(root.position)), { type: 'Program', sourceType: options.sourceType || 'module', body: [], comments: [], tokens: [] });
        this._services = {
            JSXElementsWithHTMLComments: [],
        };
        if (isMdx) {
            traverse(root, {
                enter: (node, parent) => {
                    if (!ES_NODE_TYPES.includes(node.type)) {
                        return;
                    }
                    let normalized = this.normalizeJsxNode(node, parent, options);
                    normalized = Array.isArray(normalized) ? normalized : [normalized];
                    normalized.forEach(_node => this._nodeToAst(_node, options));
                },
            });
        }
        return {
            ast: this._ast,
            services: this._services,
        };
    }
    // @internal
    _eslintParse(code, options) {
        if (!this._parsers || options.parser !== this._options.parser) {
            this._parsers = normalizeParser(options.parser);
        }
        /* istanbul ignore else */
        if (options.filePath && this._options !== options) {
            Object.assign(this._options, options);
        }
        let program;
        let parseError;
        for (const parser of this._parsers) {
            try {
                program = parser(code, this._options);
                break;
            }
            catch (e) {
                if (!parseError) {
                    parseError = e;
                }
            }
        }
        if (!program && parseError) {
            throw parseError;
        }
        /* istanbul ignore next */
        return ('ast' in program && program.ast
            ? program
            : { ast: program });
    }
    // fix adjacent JSX nodes
    // @internal
    // eslint-disable-next-line sonarjs/cognitive-complexity
    _normalizeJsxNodes(node, options) {
        const value = node.value;
        let program;
        try {
            // wrap into single element which is valid jsx but not valid jsx in mdx, so that it won't break on adjacent JSX nodes
            program = this._eslintParse(`${JSX_WRAPPER_START}${value}${JSX_WRAPPER_END}`, options).ast;
        }
        catch (e) {
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                const { position: { start }, } = node;
                e.index += start.offset - OFFSET;
                e.column =
                    /* istanbul ignore next */
                    e.lineNumber > 1 ? e.column : e.column + start.column - OFFSET;
                e.lineNumber += start.line - 1;
                throw e;
            }
            return node;
        }
        const { expression } = program
            .body[0];
        if (!isJsxNode(expression) || expression.children.length <= 1) {
            return node;
        }
        const { position: { start: { line, offset }, }, } = node;
        return expression.children.reduce((nodes, jsNode) => {
            if (!isJsxNode(jsNode)) {
                return nodes;
            }
            const { start: nodeStart, end: nodeEnd, 
            /* istanbul ignore next */
            loc: { start, end } = {
                start: { column: nodeStart, line: 1 },
                end: { column: nodeEnd, line: 1 },
            }, 
            /* istanbul ignore next */
            range = [nodeStart, nodeEnd], } = jsNode;
            const startLine = line + start.line - 1;
            const endLine = line + end.line - 1;
            const startOffset = range[0] - OFFSET;
            const endOffset = range[1] - OFFSET;
            nodes.push({
                type: 'jsx',
                data: nodes.length > 0 ? null : node.data,
                value: value.slice(startOffset, endOffset),
                position: {
                    start: {
                        line: startLine,
                        column: line === startLine ? start.column - OFFSET : start.column,
                        offset: offset + startOffset,
                    },
                    end: {
                        line: endLine,
                        column: line === startLine ? end.column - OFFSET : end.column,
                        offset: offset + endOffset,
                    },
                },
            });
            return nodes;
        }, []);
    }
    // @internal
    _nodeToAst(node, options) {
        if (node.data && node.data.jsxType === 'JSXElementWithHTMLComments') {
            this._services.JSXElementsWithHTMLComments.push(node);
        }
        const value = node.value;
        // fix #4
        if (isComment(value)) {
            return;
        }
        const { loc, start } = normalizePosition(node.position);
        const startLine = loc.start.line - 1; // ! line is 1-indexed, change to 0-indexed to simplify usage
        let program;
        try {
            program = this._eslintParse(value, options).ast;
        }
        catch (e) {
            /* istanbul ignore if */
            if (hasProperties(e, LOC_ERROR_PROPERTIES)) {
                // should be handled by `_normalizeJsxNodes`, just for robustness
                e.index += start;
                e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
                e.lineNumber += startLine;
            }
            throw e;
        }
        const offset = start - program.range[0];
        AST_PROPS.forEach(prop => this._ast[prop].push(
        // unfortunately, TS complains about incompatible signature
        // @ts-ignore
        ...program[prop].map(item => restoreNodeLocation(item, startLine, offset))));
    }
}
const parser = new Parser();
const { parse, parseForESLint } = parser;

export { AST_PROPS, CLOSE_TAG_REGEX, COMMENT_CONTENT_REGEX, COMMENT_REGEX, DEFAULT_EXTENSIONS, DEFAULT_PARSER_OPTIONS, ES_NODE_TYPES, FALLBACK_PARSERS, JSX_TYPES, LOC_ERROR_PROPERTIES, MARKDOWN_EXTENSIONS, OPEN_CLOSE_TAG_REGEX, OPEN_TAG_REGEX, Parser, SELF_CLOSING_TAG_REGEX, Traverse, closeTag, comment, commentClose, commentOpen, first, hasProperties, isCloseTag, isComment, isJsxNode, isOpenCloseTag, isOpenTag, isSelfClosingTag, last, mdxProcessor, normalizeParser, normalizePosition, openTag, parse, parseForESLint, parser, restoreNodeLocation, selfClosingTag, traverse };
